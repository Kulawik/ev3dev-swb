% \documentclass[11pt]{report}
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage[a4paper]{geometry}
\usepackage[polish]{babel}
\usepackage{hyperref}
\usepackage{polski}
\usepackage{csquotes}
\DeclareQuoteStyle[quotes]{polish}
  {\quotedblbase}
  {\textquotedblright}
  [0.05em]
  {\quotesinglbase}
  {\fixligatures\textquoteright}
\DeclareQuoteAlias[quotes]{polish}{polish}
% \DeclareQuoteOption{polish}

\usepackage[backend=biber, citestyle=ieee]{biblatex}
% \bibliography{bibliography}
\usepackage{graphicx}

\usepackage{tabularx}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{threeparttable}
\newcolumntype{Y}{>{\centering\arraybackslash}X}

\graphicspath{{plots/}}

\usepackage{listings}
\usepackage{lmodern}% http://ctan.org/pkg/lm
% \usepackage{listings}
% \usepackage{enumitem}
\usepackage{float}
% \lstset{language=[x86masm]Assembler}
\usepackage{multicol}
\usepackage{color}
\usepackage{xcolor}

\definecolor{darkgreen}{rgb}{0.09, 0.45, 0.27}
\lstdefinestyle{customc}{
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  numbers=left,
  % numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\ttfamily,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color{darkgreen},
  stringstyle=\color{red}
  }

% \lstset{escapechar=@,style=customc}
\lstset{style=customc}

\begin{document}


\begingroup
    \centering
    \LARGE\textbf{Raport końcowy projektu SWB 2016Z}\\[0.75em]
    \vspace{0.2cm}
    {\large\itshape Maciej Kulawik, Łukasz Neumann\par}
    \vspace{0.5cm}
    {\large 25.01.2016\par}
\endgroup

\section{Opis projektu}
Celem projektu zrealizowanego w ramach naszej współpracy z dr Dobrowolskim było
stworzenie środowiska do kompilacji skrośnej aplikacji pisanych w języku C i C++
na system ev3dev działający na sterownikach LEGO MINDSTORMS. Dodatkowo naszym
zadaniem było stworzenie biblioteki w języku C++ ułatwiającego implementację maszyn
stanów dla zestawów LEGO MINDSTORMS. Biblioteka z założenia użyta zostanie w
przyszłości przez studentów w laboratorium przedmiotu SWB. Szczegółowy zakres
ustalonych prac został opisany w Sekcji~\ref{prace_ustalone}. Cele projektu udało
się zrealizować, a dokładny opis wykonanych prac został umieszczony w
Sekcji~\ref{prace_wykonane}. Opis interfejsu dostarczonej biblioteki,
instrukcja instalacji środowiska i biblioteki, oraz dokumentacja znajdują się odpowiednio w
Sekcjach~\ref{user_api},~\ref{installation}~i~\ref{docs}.

\section{Zakres ustalonych prac}\label{prace_ustalone}
\begin{itemize}
    \item Instalacja na dwóch komputerach:
        \begin{itemize}
            \item serwera Ubuntu v16.04 w maszynie wirtualnej Hyper-V, w środowisku Win10
            \item instalacja na Ubuntu środowiska ev3dev (brickstrap --- jako guestfs) oraz narzędzi (kompilatory C i C++ itd.)
            \item instalacja narzędzi do aktualizacji/modyfikacji i tworzenia obrazu systemu wgrywanego na SDHC do EV3
            \item instalacja narzędzi do kompilacji skrośnej z użyciem aplikacji Docker
        \end{itemize}
    \item Sprawdzić środowisko kompilacji skrośnej na przykładach:
        \begin{itemize}
            \item \url{https://github.com/theZiz/ev3c}
            \item \url{https://github.com/ddemidov/ev3dev-lang-cpp}
        \end{itemize}
    \item Dostarczenie biblioteki do C++ dostarczającej abstrakcji służących do
        implementacji maszyn stanów dla środowiska ev3dev.
    \item Złożenie dwóch zestawów LEGO i uruchomienie środowiska ev3dev na
        sterownikach zestawów.
\end{itemize}
\section{Opis wykonanych prac}\label{prace_wykonane}
\subsection{Instalacja systemów Ubuntu}
Instalacja systemów Ubuntu w maszynie wirtualnej Hyper-V nie przysporzyła
żadnych problemów, należy postępować zgodnie z instrukcjami wyświetlanymi na
ekranie.
Jedynym odstępstwem od normalnej procedury jest konieczność
wyłączenia opcji bezpiecznego rozruchu (ang. secure boot)
w ustawieniach utworzonej maszyny wirtualnej.\\
W laboratorium z powodzeniem zainstalowaliśmy dwa systemy Ubuntu w wersji 14.04, a następnie
jedną maszynę z systemem Ubuntu 16.04.
\subsection{Instalacja na Ubuntu środowiska ev3dev, oraz narzędzi}
Gdy zaczynaliśmy prace nad projektem (sierpień 2016) jedyną możliwością natywnej
kompilacji skrośnej na sterownik LEGO MINDSTORMS było użycie narzędzia
\texttt{brickstrap}. Jest to narzędzie służące do instalacji systemu Debian na
sterowniku LEGO MINDSTORMS, a także udostępniające możliwość kompilacji skrośnej
bez konieczności emulacji architektury sterownika. Dzięki narzędziu kompilacja
jest znacząco szybsza w porównaniu do metod emulujących architekturę urządzenia
i kompilujących projekty w wirtualnym środowisku.\\
Instalacja środowiska \texttt{brickstrap} do celów kompilacji okazała się
niełatwym zadaniem. Wynika to z faktu rozbieżności instrukcji instalacji i
użycia narzędzia dostarczonej na stronie\newline
\url{http://www.ev3dev.org/docs/tutorials/using-brickstrap-to-cross-compile/} ze
stanem faktycznym narzędzia, co w połączeniu z nieudokumentowanymi zmianami
zarówno w interfejsie, jak i nazewnictwie pewnych składowych narzędzia
sprawiło, że na ten problem poświęciliśmy sporą część czasu.\\
Na początku września autorzy ev3dev wprowadzili nową metodę natywnej kompilacji
skrośnej i zakończyli wsparcie dla kompilacji przy pomocy \texttt{brickstrap}.
Ponieważ w ramach projektu, przed ogłoszeniem nowej metody, powstała poprawna,
sprawdzona i działająca instrukcja~\ref{instr_brickstrap}
instalacji i konfiguracji narzędzia \texttt{brickstrap} umieszczamy ją w
raporcie na wypadek, gdyby czytelnik zechciał użyć tego narzędzia, pomimo braku
oficjalnego wsparcia.
\subsection{Instalacja środowiska kompilacji skrośnej opartego na aplikacji
    docker}
Po wprowadzeniu przez autorów ev3dev możliwości kompilacji skrośnej w oparciu o
narzędzie \texttt{docker} postanowiliśmy stworzyć instrukcję instalacji tego
narzędzia, a także dostarczyć skrypt, który w prosty sposób pozwalałby
użytkownikom na kompilację całego projektu. Ta decyzja została podjęta po
wstępnych próbach użycia narzędzia, podczas których okazało się być ono o wiele
łatwiejsze w obsłudze, zarówno pod względem instalacji, jak i utrzymania.
Nieocenionym wydaje się być prostota zamrożenia wersji ev3dev, która często bywa
zmieniana przez autorów bez wsparcia dla starszych wersji. Instrukcja instalacji
środowiska i jego użycia została opisana w Sekcji~\ref{instr_docker}. Warto
podkreślić, że kompilacja skrośna przy użyciu narzędzia \texttt{docker} zadziała
na każdym systemie wspierającym to narzędzie.
\subsection{Sprawdzenie środowiska kompilacji skrośnej na przykładach}
Obydwa przykłady zostały sprawdzone zarówno przy użyciu narzędzia
\texttt{brickstrap}, jak i narzędzia \texttt{docker}.
Przy użyciu narzędzia \texttt{docker} w przykładzie projektu z C należało
zdefiniować zmienną \texttt{CC} w pliku \texttt{Makefile} zgodnie z instrukcją,
a przykład C++ skompilować za pomocą skryptu \texttt{docker\_build.sh}.
Przykłady kompilują się przy użyciu obydwu narzędzi.
\subsection{Złożenie zestawów LEGO i uruchomienie ev3dev na sterownikach
    zestawów}
W ramach projektu złożyliśmy dwa zestawy LEGO i podłączyliśmy sensory do
sterownika głównego. Uruchomienie środowiska ev3dev na sterownikach okazało się
proste, aczkolwiek instrukcja umieszczona na stronie ev3dev
(\url{http://www.ev3dev.org/docs/getting-started/}) wskazuje na użycie aplikacji
\texttt{Etcher} w celu stworzenia karty SD z obrazem środowiska. Pomimo prób
użycia tej aplikacji zarówno na systemie Windows, jak i Linux nie udało nam
się stworzenie takiej karty przy pomocy aplikacji --- dostawaliśmy nieczytelne
błędy. Po kilku nieudanych próbach z powodzeniem użyliśmy komendy \texttt{dd}
dostępnej w systemie Linux w następujący sposób:
\begin{verbatim}
    sudo dd bs=4M if=./ev3-ev3dev.img of=/dev/sdc status=progress && sync
\end{verbatim}
gdzie \texttt{ev3-ev3dev.img} to nazwa obrazu pobranego ze strony ev3dev, a
\texttt{/dev/sdc} to ścieżka do karty SD.\\
Pozostała część instrukcji instalacji środowiska ev3dev na sterowniku LEGO
MINDSTORMS okazała się być poprawna.
\subsection{Implementacja biblioteki do tworzenia maszyn stanów}
W celu ułatwienia użytkownikowi pracy z biblioteką ev3dev zaimplementowaliśmy w
języku C++ bibliotekę pozwalającą na proste opisywanie maszyn stanów. Poniżej
opisujemy podstawowe własności powstałej biblioteki.
\subsubsection*{Równoległość}
Przedstawione rozwiązanie używa dwóch wątków, aby symultanicznie czytać stan
sensorów i motorów podłączonych do urządzenia, oraz realizować maszynę stanów
wraz z odpowiednimi komendami do motorów.
\subsubsection*{Zapewnienie synchronizacji dostępu do sensorów i motorów}
Biblioteka ev3dev nie synchronizuje w żaden sposób dostępu do sensorów i motorów
urządzenia. Z tego powodu, aby zapewnić bezpieczne czytanie i pisanie danych do
urządzeń, dostarczamy specjalnych `opakowań' na każde z fizycznych urządzeń,
które działa identycznie jak obiekt, który opakowuje, jednocześnie gwarantując
poprawną synchronizację między wątkami.
\subsubsection*{Interfejs logowania zdarzeń}
Ponieważ znajdowanie błędów w programie opartym o fizyczne urządzenia może być
czasochłonne i trudne, biblioteka udostępnia interfejs logowania danych.
Użytkownik może w prosty sposób oznaczać poziom ważności komunikatów, dostaje
też informację o dokładnym czasie komunikatu, oraz ID wątku który go
wygenerował. Przykładowy sposób użycia interfejsu został pokazany poniżej.
\begin{lstlisting}
#include "Logger.hpp"

int main() {
    INFO << "Info message!";
    WARNING << "Warning message!";
}
\end{lstlisting}
\subsubsection*{Interfejs użytkownika}
Dostarczona biblioteka udostępnia interfejs użytkownika, który może być
w łatwy sposób dostosowany do konkretnej architektury urządzeń zewnętrznych.
Ponadto implementacja maszyny stanów na podstawie biblioteki pozwala w prosty
sposób pisać maszyny stanów, a utworzony w ten sposób kod jest zwięzły i
klarowny. Dokładny opis interfejsu, wraz z przykładem użycia biblioteki znajduje
się w Podsekcji~\ref{user_api}.

\section{Przykład użycia biblioteki i opis jej interfejsu}\label{user_api}
Poniżej przedstawiamy bardzo prostą implementację maszyny stanów w oparciu o dostarczoną
bibliotekę. Przykład oparty jest o zestaw nr 45544, w związku z czym
niepotrzebna jest zmiana implementacji żadnego z obiektów biblioteki.
\begin{lstlisting}
#include <chrono>
#include "CraneData.hpp"
#include "CraneControl.hpp"
#include "State.hpp"
#include "EventLoop.hpp"
#include "Logger.hpp"

typedef CraneControl Control;
typedef CraneData<Control> Data;

void go_right_action(Control& crane, const Data& data) {
    crane.motor(MotorLabel::C)->set_speed_sp(200);
    crane.motor(MotorLabel::C)->set_command("run-forever");
}

void stop_rl_action(Control& crane, const Data& data) {
    SafeMotor motor = crane.motor(MotorLabel::C);
    motor->set_command("stop");
}

void go_center_action(Control& crane, const Data& data) {
    crane.motor(MotorLabel::C)->set_position(0);
    crane.motor(MotorLabel::C)->set_position_sp(-270);
    crane.motor(MotorLabel::C)->set_speed_sp(-200);
    crane.motor(MotorLabel::C)->set_command("run-to-abs-pos");
}

bool condition_A_to_B(const Data& data, const Time& time_in_state) {
    return data.touch_is_pressed;
}

bool after1s(const Data&, const Time& time) {
    return time > std::chrono::seconds(1);
}

int main() {
    State<Data, Control> state_A, state_B;


    state_A.addAction(go_right_action);
    // (condition callback, target state)
    state_A.addTransition(condition_A_to_B, &state_B);

    state_B.addAction(stop_rl_action);
    state_B.addAction(go_center_action);
    // nullptr denotes the end of state machine
    state_B.addTransition(after1s, nullptr);
    state_B.setTimeout(std::chrono::seconds(1));

    Control& control = Control::getInstance();
    Poller<Data> poller((Data(control)));
    EventLoop<Data, Control> loop(control, poller);

    std::thread poller_thread([&poller](){poller.work();});
    loop.run(&state_A);

    poller.end();
    poller_thread.join();
    return 0;
}
\end{lstlisting}
W przykładzie pokazano implementację maszyny stanów. Wchodząc do stanu A silnik
C zaczyna pracować ze stałą prędkością, co przekłada się na ruch ramienia w
prawo. Pod wpływem sygnału z sensora dotyku maszyna przechodzi ze stanu A do
stanu B. Przy wejściu do stanu B silnik C jest najpierw zatrzymywany, po czym
przechodzi do pozycji absolutnej zadanej odp. parametrami, co w przypadku
ramienia robota wyśrodkowuje ramię. Następnie po czasie 1 sekundy maszyna stanów
kończy swoje działanie. W celu zastosowania warunku przejścia zależnego od czasu
należy ustawić dla danego stanu okres z jakim będą sprawdzane warunki przejścia
przy pomocy metody~\texttt{setTimeout}. \\
\subsection{Opis interfejsu użytkownika}
Użytkownik powinien zawsze stworzyć obiekty \texttt{CraneControl}, \texttt{Poller},
\texttt{EventLoop}, a także odp. stany, reprezentowane przez klasy
\texttt{State}. Opis maszyny uzyskuje się za pomocą dodawania do stanów akcji,
które mają być wykonane przy wejściu do danego stanu, oraz warunków przejść
pomiędzy stanami. Poniżej opisano niektóre klasy/funkcje/reprezentacje pod kątem
tworzenia nowej maszyny stanów. Wszystkie klasy dodatkowo opisane są w
dostarczonej dokumentacji~\ref{docs}. Użytkownik powinien zwrócić uwagę na dwie
klasy, które powinny zostać odpowiednio zmodyfikowane, aby spełniały wymagania
użytkownika, zostały one opisane w Podsekcji~\ref{modifiable}.
\subsubsection*{Akcje}
Każda akcja reprezentowana jest przez funkcję zwracającą typ \texttt{void} i posiadającą dwa argumenty:
referencję na kontroler (\texttt{CraneControl\&}), oraz referencję na aktualne dane
(\texttt{CraneData<CraneControl>\&}). Kontroler służy do wydawania poleceń poszczególnym silnikom, a
obiekt danych reprezentuje najnowsze odczyty różnych parametrów sensorów i
silników. Użytkownik nie powinien czytać danych w funkcjach akcji poprzez
kontroler, a używać dostarczonych danych. Warto nadmienić, że
implementacja struktury \texttt{CraneData<T>} dostarczana jest przez użytkownika, co
pozwala mu na kontrolę nad danymi, których może używać w funkcjach akcji.\\
Akcja rejestrowana jest w stanie poprzez wywołanie metody \texttt{addAction}
danego stanu, która w argumencie przyjmuje wskaźnik na funkcję akcji.
\subsubsection*{Przejścia między stanami}
Przejście między stanami określone jest przez funkcję warunku, oraz stan do
którego przejście się ma odbyć. Funkcja warunku dostaje dwa parametry:
referencję na aktualne dane (\texttt{CraneData<CraneControl>\&}), a także
referencję na czas, jaki upłynął od momentu wejścia do stanu (\texttt{Time\&}).
Na podstawie tych argumentów funkcja powinna zwrócić wartość boolowską, gdzie
wartość \texttt{true} oznacza decyzję o przejściu, natomiast wartość
\texttt{false} decyzję o braku przejścia (pozostaniu w aktualnym stanie).\\
W celu rejestracji przejścia należy dla stanu, z którego chcemy dokonać
przejścia, wywołać metodę \texttt{addTransition}, która przyjmuje dwa argumenty:
wskaźnik na funkcję warunku, oraz wskaźnik na stan, do którego maszyna stanów
przejdzie, jeśli funkcja warunku zwróci \texttt{true}. Stan końcowy
reprezentowany jest przez wartość \texttt{nullptr}.
\subsubsection*{Kontroler}
Kontroler jest w architekturze biblioteki singletonem, w związku z czym jedynym
sposobem na zadeklarowanie i użycie jego obiektu następuje poprzez wywołanie
metody \texttt{CraneControl::getInstance()}, która zwraca referencję na
kontroler. Takie rozwiązanie podyktowane jest zapewnieniem bezpiecznej
synchronizacji dostępu do sprzętu.
\subsubsection*{Agregator danych}
Agregator danych zajmuje się odpytywaniem poszczególnych urządzeń zewnętrznych i
zapisywaniu ich parametrów. Tworzy się go podając w konstruktorze
strukturę \texttt{CraneData<CraneControl>}, która z kolei w konstruktorze
przyjmuje referencję na kontroler.\\
Agregator danych powinien być uruchamiany w oddzielnym wątku, tak jak zostało to
zaprezentowane na ww. przykładzie. Aby uruchomić agregator należy wywołać jego
metodę \texttt{work}, a żeby go zatrzymać --- \texttt{end}.
\subsubsection*{Pętla główna maszyny stanów}
Pętla główna maszyny stanów realizuje przejścia pomiędzy stanami, oraz trzyma
informacje o aktualnym stanie. Pętlę główną tworzy się podając jej w
konstruktorze referencje na kontroler i agregator danych.\\
Pętlę główną (a co za tym idzie całą maszynę stanów) uruchamia się wywołując jej
metodę \texttt{run}, której argumentem jest wskaźnik na stan początkowy
automatu. \textbf{Przed uruchomieniem pętli głównej użytkownik musi upewnić się,
że agregator danych działa.}
\subsection{Obiekty zmieniane przez użytkownika}\label{modifiable}
Aby poprawnie zarządzać sprzętem podpiętym pod sterownik LEGO MINDSTORMS
użytkownik powinien zaznajomić się, i w razie potrzeb zmodyfikować dwa obiekty:
\texttt{CraneData}, oraz \texttt{CraneControl}. Implementacja tych obiektów w
niniejszym projekcie opisuje konfigurację sprzętową ramienia LEGO z zestawu nr
45544.
\subsubsection*{CraneControl}
W implementacji tej klasy użytkownik powinien zadeklarować jako prywatne wszystkie urządzenia
fizyczne użyte w projekcie poprzez ich obiekty w bibliotece ev3dev, a także
obiekty \texttt{mutex}, po jednym na każde urządzenie zewnętrzne. Dodatkowo
użytkownik powinien udostępnić sposób komunikacji z tymi urządzeniami za
pomocą metod publicznych, które zwracają obiekty biblioteki ev3dev opakowane w
klasę Safe. Poniżej przedstawiamy przykładową implementację kontrolera dla
jednego zewnętrznego urządzenia --- sensora koloru.
\begin{lstlisting}
#ifndef CRANECTRL_HPP
#define CRANECTRL_HPP

#include <mutex>
#include <chrono>
#include <utility>

#include "Safe.hpp"
#include "ev3dev.h"

typedef std::chrono::milliseconds Time;
typedef Safe<ev3dev::color_sensor> SafeColorSensor;

/*
 * Controler of the hardware. Stores all necessary motors and sensors together
 * with mutexes. This class is a singleton.
 */
class CraneControl {
public:
    // Singleton - can only be obtained by this method.
    static CraneControl& getInstance() {
        // Guaranteed to be destroyed.
        static CraneControl instance;
        // Instantiated on first use.
        return instance;
    }

    SafeColorSensor color_sensor() {
        return SafeColorSensor(color_sensor_mutex_, color_sensor_);
    }
private:
    CraneControl() {}
    CraneControl(const CraneControl&) = delete;
    void operator=(const CraneControl&) = delete;

    std::mutex color_sensor_mutex_;

    ev3dev::color_sensor color_sensor_ = ev3dev::color_sensor(ev3dev::INPUT_3);
};
#endif
\end{lstlisting}
\subsubsection*{CraneData}
Struktura \texttt{CraneData} służy do przechowywania parametrów
urządzeń zewnętrznych, które są przydatne dla użytkownika. Struktura powinna
dodatkowo udostępniać operator porównania, a także konstruktor kopiujący, obydwa
zdefiniowane przez użytkownika i odpowiadające przetrzymywanym danym. Poniżej
przedstawiamy przykładową implementację struktury \texttt{CraneData} dla jednego
urządzenia zewnętrznego --- sensora koloru.
\begin{lstlisting}
#ifndef CRANEDATA_HPP
#define CRANEDATA_HPP

#include "CraneControl.hpp"

/*
 * Container for sensors/motors data.
 */
template <class Control>
struct CraneData {
    CraneData(Control& control) : control_(control) {}
    void update() {
        // get color
        color_intensity = control_.color_sensor()->reflected_light_intensity();
    }

    bool operator==(const CraneData<Control> &other) const {
        return other.color_intensity == color_intensity;
    }

    bool operator!=(const CraneData<Control> &other) const {
        return !(*this == other);
    }

    CraneData& operator=(const CraneData<Control> &other) {
        color_intensity = other.color_intensity;
        return *this;
    }

    // color
    int color_intensity;

    private:
        Control& control_;
};

#endif
\end{lstlisting}
\section{Instrukcja instalacji}\label{installation}
\subsection{Instalacja środowiska kompilacji}
\subsubsection*{Instalacja środowiska brickstrap}\label{instr_brickstrap}
Wszystkie skrypty użyte w tej instrukcji są również dostępne w katalogu
\texttt{./scripts} w repozytorium. Metoda opisana poniżej została
przetestowana na systemie operacyjnym Ubuntu 16.04.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Uruchom skrypt instalacji \texttt{brickstrap}
  (\texttt{scripts/install\_bricktrap.sh}):\\
  \begin{verbatim}
   sudo apt-key adv --keyserver pgp.mit.edu --recv-keys 2B210565
   sudo apt-add-repository "deb http://archive.ev3dev.org/ubuntu trusty main"
   sudo apt-get update
   sudo apt-get install -y brickstrap

   # create a supermin appliance
   sudo update-guestfs-appliance
   # add yourself to the kvm group
   # need to log out and back in for this to take effect
   sudo usermod -a -G kvm $USER
   newgrp kvm
   # fix permissions on /boot/vmlinuz*
   sudo chmod +r /boot/vmlinuz*
   # And you need to add yourself to /etc/subuid and /etc/subgid to be able
   # to use uid/gid mapping.
   sudo usermod --add-subuids 200000-265534 --add-subgids 200000-265534 $USER

   # create virtual environment
   mkdir work
   cd work
    -p argument from ls /usr/share/brickstrap/projects
    -c argument form ls /usr/share/brickstrap/projects/ev3dev-jessie
   brickstrap -p ev3dev-jessie -c ev3 -d ev3-rootfs create-rootfs
   brickstrap -d ev3-rootfs shell << EOF
   apt-get update
   apt-get install -y build-essential
   EOF
  \end{verbatim}
\item
  Zainstaluj środowisko kompilacja skrośnej z \texttt{cmake} w wersji
  3.x:
  \begin{itemize}
  \item
    Zainstaluj \texttt{CMake} w wersji 3.5:
    \begin{verbatim}
     sudo apt-get install cmake
    \end{verbatim}
\item Zainstaluj zależności w powłoce \texttt{brickstrap}:
    \begin{verbatim}
     cat > /etc/apt/sources.list <<EOL
     deb http://cdn.debian.net/debian jessie main contrib non-free
     deb-src http://cdn.debian.net/debian jessie main contrib non-free

     deb http://archive.ev3dev.org/debian jessie main
     deb-src http://archive.ev3dev.org/debian jessie main
     EOL
     apt-get update
     apt-get build-dep brickman
     apt-get install symlinks
     symlinks -c /usr/lib/arm-linux-gnueabi
    \end{verbatim}

  \item
    Wyjdź z powłoki \texttt{brickstrap} i przygotuj środowisko CMake'a
    (\texttt{scripts/prepare\_cmake\_env.sh}):
    \begin{verbatim}
    sudo apt-get install gcc-arm-linux-gnueabi g++-arm-linux-gnueabi \
        cmake valac pkg-config
    cd ~/work
    cat > arm-linux-gnueabi.cmake <<EOL
    set(CMAKE_SYSROOT $ENV{HOME}/work/ev3-rootfs/rootfs)

    set(CMAKE_SYSTEM_NAME Linux)

    set(CMAKE_C_COMPILER arm-linux-gnueabi-gcc)
    #set(CMAKE_CXX_COMPILER arm-linux-gnueabi-g++)

    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
    EOL
    cat > ev3-rootfs-cross.env <<EOL
    SYSROOT_PATH=${HOME}/work/ev3-rootfs/rootfs

    export PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1
    export PKG_CONFIG_ALLOW_SYSTEM_LIBS=1
    export PKG_CONFIG_SYSROOT_DIR=${SYSROOT_PATH}
    export PKG_CONFIG_LIBDIR=${SYSROOT_PATH}/usr/lib/arm-linux-gnueabi/pkgconfig
    export PKG_CONFIG_LIBDIR="$PKG_CONFIG_LIBDIR:\
    $SYSROOT_PATH/usr/lib/pkgconfig"
    export PKG_CONFIG_LIBDIR="$PKG_CONFIG_LIBDIR:\
    $SYSROOT_PATH/usr/share/pkgconfig"
    export PKG_CONFIG_LIBDIR="$PKG_CONFIG_LIBDIR:\
    $SYSROOT_PATH/usr/local/lib/arm-linux-gnueabi/pkgconfig"
    export PKG_CONFIG_LIBDIR="$PKG_CONFIG_LIBDIR:\
    $SYSROOT_PATH/usr/local/lib/pkgconfig"
    export PKG_CONFIG_LIBDIR="$PKG_CONFIG_LIBDIR:\
    $SYSROOT_PATH/usr/local/share/pkgconfig"


    export XDG_DATA_DIRS="$SYSROOT_PATH/usr/local/share:\
    $SYSROOT_PATH/usr/share"
    EOL
    \end{verbatim}
\item Użyj polecenia:
    \begin{verbatim}
     source ./ev3-rootfs-cross.env
    \end{verbatim}
    \end{itemize}
\item Skonfiguruj środowisko kompilacji oparte o pliki \texttt{Makefile}.
    \begin{itemize}
        \item Stwórz plik \texttt{Makefile} (przykładowy plik w katalogu
            \texttt{examples/}):
            \begin{verbatim}
     PROGRAM = my-program
     CROSS_COMPILE = arm-linux-gnueabi-
     SYSROOT = $(HOME)/work/ev3-rootfs/rootfs

     CC=$(CROSS_COMPILE)gcc
     LD=$(CROSS_COMPILE)ld
     CFLAGS= --sysroot=$(SYSROOT) -g -I$(SYSROOT)/usr/include

     all: $(PROGRAM)

     LIBDIR = -L=/usr/lib/arm-linux-gnueabi
     #LIBDIR = -L$(SYSROOT)/usr/lib/arm-linux-gnueabi

     LIBS = -lpthread

     LDFLAGS= $(LIBDIR) $(LIBS)
     SOURCE = my_program.c

     OBJS = $(SOURCE:.c=.o)

     $(PROGRAM): $(OBJS)
         $(CC) -o $@ $(OBJS) $(LDFLAGS)

     clean:
         rm -f $(OBJS) $(PROGRAM)
            \end{verbatim}

  \item Użyj pliku \texttt{Makefile} do skompilowania projektu
    \end{itemize}
\end{enumerate}
\subsubsection*{Instalacja środowiska docker}\label{instr_docker}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Zainstaluj najnowszą wersję aplikacji \texttt{docker} dla swojego systemu
  operacyjnego. Dla Ubuntu 14.04 skrypt do instalacji znajduje się
  repozytorium, w pliku \texttt{scripts/install\_docker.sh}, natomiast dla
  innych systemów instrukcja instalacji znajduje się na stronie
  \href{https://docs.docker.com/engine/installation/}{}. Upewnij się, że
  użytkownik został poprawnie dodany do grupy \texttt{docker} w systemie
  operacyjnym.
\item
  Ściągnij obraz zawierający środowisko kompilacji i odpowiednio go
  oznacz:

  \begin{verbatim}
      docker pull fuine/ev3cc:v2
      docker tag fuine/ev3cc:v2 ev3cc
\end{verbatim}
\item
  Użyj skryptu \texttt{scripts/docker\_build.sh} do budowania swoich projektów,
  opartych o narzędzie \texttt{CMake}. Przykładowy plik \texttt{CmakeLists/txt}
  znajduje się w katalogu \texttt{pidtest/}, a dodatkową pomoc dot.\ skryptu
  można uzyskać uruchamiając go z flagą \texttt{-\/-help}.\\ W przypadku
  projektów pisanych w języku C standardowy plik \texttt{Makefile} działa, pod
  warunkiem, że użytkownik użyje kompilatora o nazwie
  \texttt{arm-linux-gnueabi-gcc}.
\end{enumerate}
\subsection{Instalacja biblioteki}
Dostarczona biblioteka oparta jest o generyczne pliki nagłówkowe, w związku z
czym użytkownik powinien zapewnić, że biblioteka jest widoczna w ścieżce
`include' kompilatora, a następnie użyć wyspecjalizowanych typów z biblioteki.
Przykładowy projekt pokazujący użycie biblioteki do budowy prostej maszyny
stanów jest pokazany w Sekcji~\ref{user_api}. Ponadto użytkownicy mogą chcieć
zmieniać klasę \texttt{CraneControl} i/lub strukturę \texttt{CraneData}, tak jak
zostało to opisane w Podsekcji~\ref{modifiable}, w związku z czym proponujemy
zainstalować bibliotekę w miejscu znanym użytkownikowi, z uprawnieniami
pozwalającymi na jej modyfikację.
\section{Dokumentacja}\label{docs}
Dostarczona biblioteka została napisana w oparciu o język angielski, w związku z
czym dokumentacja również jest pisana w tym języku, w celu zapewnienia spójności
tekstu z implementacją i komentarzami w źródłach biblioteki.
\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Short overview of the classes in the provided ev3dev lego framework. All
classes have been implemented for the basic mechanical-arm lego set.
Different implementations of the classes should base on the provided
ones. Classes should be reimplemented to match the underlying lego set
unless stated otherwise. For the example usage of the framework see
\textit{draft.cpp} file.

\subsection*{Safe}\label{safe}

\texttt{Safe} class is a wrapper around given data and corresponding
mutex. It is primarily used to provide thread-safe access to the
underlying hardware. It provides overloaded dereference and arrow
operators.

\textbf{Users should not change the implementation of the \texttt{Safe}
class}

\subsection*{CraneControl}\label{cranecontrol}

Controller for the hardware. It should contain all hardware handles used
throughout application and corresponding mutexes. It should also
implement methods providing thread-safe access to the underlying
hardware by wrapping hardware handle and corresponding mutex in the
\texttt{Safe} class instance.

See \textit{CraneControl.cpp} for an example
implementation.

\subsection*{CraneData}\label{cranedata}

This class represents all data from external sensors, which is
neccessary to trigger transitions in state machine. It should implement
two methods: * \texttt{update} - updates all data fields * \texttt{==}
operator - used to compare old read with new one and indicate possible
change in the reads. User might include eventual tollerance for chosen
parameters. Please note that \texttt{update} method will be running in a
tight loop, therefore it is crucial to read neccessary data only.

\texttt{CraneData} interacts with underlying hardware via
\texttt{CraneControl} instance provided as a reference in the
constructor.

See \textit{CraneData.cpp} for an example
implementation.

\subsection*{Poller}\label{poller}

Class responsible for polling the underlying hardware and providing
thread-safe mechanism for acquiring the newest data.

\textbf{Users should not change the implementation of the
\texttt{Poller} class}

\subsection*{State}\label{state}

Defines state in the state machine. This class stores \textbf{actions},
which will be executed once state will be reached, and
\textbf{transitions}.

\begin{itemize}
\item
  \textbf{Actions} are represented as functors (std::function objects)
  which receive control object reference and data object const reference
  as arguments.
\item
  \textbf{Transitions} to the next state are stored as tuples. Each
  tuple consists of a functor object (std::function) and a pointer to
  next state. Functors when called should return a boolean value
  indicating whether or not the transition should be made. Transition
  functions get the newest data and elapsed time (duration of time
  already spent in the current state) as their arguments. Each
  \texttt{State} can store multiple actions and transitions. They will
  be executed or, in case of transitions - checked, in the same order as
  they were added to the state.
\end{itemize}

\textbf{Users should not change the implementation of the \texttt{State}
class}

\subsection*{EventLoop}\label{eventloop}

Representation of the state machine. Can be run from the given starting
state via \texttt{run} method. Machine can be stopped via \texttt{stop}
method.

\textbf{Users should not change the implementation of the
\texttt{EventLoop} class}

\end{document}
